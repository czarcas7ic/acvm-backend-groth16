//! Proving and verification key management.
//!
//! This module provides structures and functions for managing Groth16 proving
//! and verification keys, including serialization, deserialization, and
//! integrity verification.
//!
//! # Security Warning
//!
//! The keys generated by the `generate_keys` function use local randomness
//! and are **NOT** suitable for production use. For production deployments,
//! you must use keys generated through a proper multi-party computation (MPC)
//! trusted setup ceremony.

use crate::errors::KeyError;
use ark_ec::pairing::Pairing;
use ark_groth16::{PreparedVerifyingKey, ProvingKey, VerifyingKey};
use ark_serialize::{CanonicalDeserialize, CanonicalSerialize};
use sha2::{Digest, Sha256};
use std::path::Path;

/// A wrapper around the Groth16 proving key with metadata.
#[derive(Clone)]
pub struct Groth16ProvingKey<E: Pairing> {
    /// The underlying arkworks proving key.
    pub key: ProvingKey<E>,
    /// SHA-256 hash of the circuit that this key was generated for.
    pub circuit_hash: [u8; 32],
    /// Version identifier for the key format.
    pub version: u32,
}

/// A wrapper around the Groth16 verification key with metadata.
#[derive(Clone)]
pub struct Groth16VerificationKey<E: Pairing> {
    /// The underlying arkworks verification key.
    pub key: VerifyingKey<E>,
    /// The prepared verification key for faster verification.
    pub prepared_key: PreparedVerifyingKey<E>,
    /// SHA-256 hash of the circuit that this key was generated for.
    pub circuit_hash: [u8; 32],
    /// Number of public inputs expected by this verification key.
    pub num_public_inputs: usize,
    /// Version identifier for the key format.
    pub version: u32,
}

/// Current version of the key serialization format.
pub const KEY_FORMAT_VERSION: u32 = 1;

/// Magic bytes for proving key files.
const PK_MAGIC: &[u8; 4] = b"G16P";

/// Magic bytes for verification key files.
const VK_MAGIC: &[u8; 4] = b"G16V";

impl<E: Pairing> Groth16ProvingKey<E> {
    /// Creates a new proving key wrapper.
    ///
    /// # Arguments
    /// * `key` - The arkworks proving key
    /// * `circuit_hash` - Hash of the circuit this key is for
    pub fn new(key: ProvingKey<E>, circuit_hash: [u8; 32]) -> Self {
        Self {
            key,
            circuit_hash,
            version: KEY_FORMAT_VERSION,
        }
    }

    /// Serializes the proving key to bytes.
    ///
    /// # Returns
    /// The serialized proving key bytes, or an error
    pub fn to_bytes(&self) -> Result<Vec<u8>, KeyError> {
        let mut bytes = Vec::new();

        // Write magic bytes
        bytes.extend_from_slice(PK_MAGIC);

        // Write version
        bytes.extend_from_slice(&self.version.to_le_bytes());

        // Write circuit hash
        bytes.extend_from_slice(&self.circuit_hash);

        // Serialize the proving key
        let mut key_bytes = Vec::new();
        self.key
            .serialize_compressed(&mut key_bytes)
            .map_err(|e| KeyError::SerializationFailed {
                message: e.to_string(),
            })?;

        // Write key length and key data
        let key_len = key_bytes.len() as u64;
        bytes.extend_from_slice(&key_len.to_le_bytes());
        bytes.extend_from_slice(&key_bytes);

        // Compute and append integrity hash
        let hash = compute_integrity_hash(&bytes);
        bytes.extend_from_slice(&hash);

        Ok(bytes)
    }

    /// Deserializes a proving key from bytes.
    ///
    /// # Arguments
    /// * `bytes` - The serialized proving key bytes
    ///
    /// # Returns
    /// The deserialized proving key, or an error
    pub fn from_bytes(bytes: &[u8]) -> Result<Self, KeyError> {
        if bytes.len() < 4 + 4 + 32 + 8 + 32 {
            return Err(KeyError::DeserializationFailed {
                message: "Data too short to be a valid proving key".to_string(),
            });
        }

        // Verify integrity hash
        let data_len = bytes.len() - 32;
        let expected_hash = &bytes[data_len..];
        let computed_hash = compute_integrity_hash(&bytes[..data_len]);
        if expected_hash != computed_hash {
            return Err(KeyError::DeserializationFailed {
                message: "Integrity check failed - key file may be corrupted".to_string(),
            });
        }

        let mut cursor = 0;

        // Read and verify magic bytes
        if &bytes[cursor..cursor + 4] != PK_MAGIC {
            return Err(KeyError::DeserializationFailed {
                message: "Invalid proving key file format".to_string(),
            });
        }
        cursor += 4;

        // Read version
        let version = u32::from_le_bytes(bytes[cursor..cursor + 4].try_into().unwrap());
        cursor += 4;

        if version != KEY_FORMAT_VERSION {
            return Err(KeyError::DeserializationFailed {
                message: format!(
                    "Unsupported key format version: {} (expected {})",
                    version, KEY_FORMAT_VERSION
                ),
            });
        }

        // Read circuit hash
        let mut circuit_hash = [0u8; 32];
        circuit_hash.copy_from_slice(&bytes[cursor..cursor + 32]);
        cursor += 32;

        // Read key length
        let key_len = u64::from_le_bytes(bytes[cursor..cursor + 8].try_into().unwrap()) as usize;
        cursor += 8;

        // Deserialize the proving key
        let key_data = &bytes[cursor..cursor + key_len];
        let key = ProvingKey::deserialize_compressed_unchecked(key_data).map_err(|e| {
            KeyError::DeserializationFailed {
                message: e.to_string(),
            }
        })?;

        Ok(Self {
            key,
            circuit_hash,
            version,
        })
    }

    /// Saves the proving key to a file.
    ///
    /// # Arguments
    /// * `path` - Path to save the key to
    pub fn save_to_file<P: AsRef<Path>>(&self, path: P) -> Result<(), KeyError> {
        let bytes = self.to_bytes()?;
        std::fs::write(path.as_ref(), bytes).map_err(|e| KeyError::IoError {
            message: e.to_string(),
        })
    }

    /// Loads a proving key from a file.
    ///
    /// # Arguments
    /// * `path` - Path to load the key from
    pub fn load_from_file<P: AsRef<Path>>(path: P) -> Result<Self, KeyError> {
        let bytes = std::fs::read(path.as_ref()).map_err(|e| {
            if e.kind() == std::io::ErrorKind::NotFound {
                KeyError::FileNotFound {
                    path: path.as_ref().display().to_string(),
                }
            } else {
                KeyError::IoError {
                    message: e.to_string(),
                }
            }
        })?;
        Self::from_bytes(&bytes)
    }

    /// Returns the raw arkworks proving key.
    pub fn into_inner(self) -> ProvingKey<E> {
        self.key
    }
}

impl<E: Pairing> Groth16VerificationKey<E> {
    /// Creates a new verification key wrapper.
    ///
    /// # Arguments
    /// * `key` - The arkworks verification key
    /// * `circuit_hash` - Hash of the circuit this key is for
    /// * `num_public_inputs` - Number of public inputs expected
    pub fn new(key: VerifyingKey<E>, circuit_hash: [u8; 32], num_public_inputs: usize) -> Self {
        let prepared_key = PreparedVerifyingKey::from(key.clone());
        Self {
            key,
            prepared_key,
            circuit_hash,
            num_public_inputs,
            version: KEY_FORMAT_VERSION,
        }
    }

    /// Serializes the verification key to bytes.
    ///
    /// # Returns
    /// The serialized verification key bytes, or an error
    pub fn to_bytes(&self) -> Result<Vec<u8>, KeyError> {
        let mut bytes = Vec::new();

        // Write magic bytes
        bytes.extend_from_slice(VK_MAGIC);

        // Write version
        bytes.extend_from_slice(&self.version.to_le_bytes());

        // Write circuit hash
        bytes.extend_from_slice(&self.circuit_hash);

        // Write number of public inputs
        bytes.extend_from_slice(&(self.num_public_inputs as u64).to_le_bytes());

        // Serialize the verification key
        let mut key_bytes = Vec::new();
        self.key
            .serialize_compressed(&mut key_bytes)
            .map_err(|e| KeyError::SerializationFailed {
                message: e.to_string(),
            })?;

        // Write key length and key data
        let key_len = key_bytes.len() as u64;
        bytes.extend_from_slice(&key_len.to_le_bytes());
        bytes.extend_from_slice(&key_bytes);

        // Compute and append integrity hash
        let hash = compute_integrity_hash(&bytes);
        bytes.extend_from_slice(&hash);

        Ok(bytes)
    }

    /// Deserializes a verification key from bytes.
    ///
    /// # Arguments
    /// * `bytes` - The serialized verification key bytes
    ///
    /// # Returns
    /// The deserialized verification key, or an error
    pub fn from_bytes(bytes: &[u8]) -> Result<Self, KeyError> {
        if bytes.len() < 4 + 4 + 32 + 8 + 8 + 32 {
            return Err(KeyError::DeserializationFailed {
                message: "Data too short to be a valid verification key".to_string(),
            });
        }

        // Verify integrity hash
        let data_len = bytes.len() - 32;
        let expected_hash = &bytes[data_len..];
        let computed_hash = compute_integrity_hash(&bytes[..data_len]);
        if expected_hash != computed_hash {
            return Err(KeyError::DeserializationFailed {
                message: "Integrity check failed - key file may be corrupted".to_string(),
            });
        }

        let mut cursor = 0;

        // Read and verify magic bytes
        if &bytes[cursor..cursor + 4] != VK_MAGIC {
            return Err(KeyError::DeserializationFailed {
                message: "Invalid verification key file format".to_string(),
            });
        }
        cursor += 4;

        // Read version
        let version = u32::from_le_bytes(bytes[cursor..cursor + 4].try_into().unwrap());
        cursor += 4;

        if version != KEY_FORMAT_VERSION {
            return Err(KeyError::DeserializationFailed {
                message: format!(
                    "Unsupported key format version: {} (expected {})",
                    version, KEY_FORMAT_VERSION
                ),
            });
        }

        // Read circuit hash
        let mut circuit_hash = [0u8; 32];
        circuit_hash.copy_from_slice(&bytes[cursor..cursor + 32]);
        cursor += 32;

        // Read number of public inputs
        let num_public_inputs =
            u64::from_le_bytes(bytes[cursor..cursor + 8].try_into().unwrap()) as usize;
        cursor += 8;

        // Read key length
        let key_len = u64::from_le_bytes(bytes[cursor..cursor + 8].try_into().unwrap()) as usize;
        cursor += 8;

        // Deserialize the verification key
        let key_data = &bytes[cursor..cursor + key_len];
        let key = VerifyingKey::deserialize_compressed_unchecked(key_data).map_err(|e| {
            KeyError::DeserializationFailed {
                message: e.to_string(),
            }
        })?;

        let prepared_key = PreparedVerifyingKey::from(key.clone());

        Ok(Self {
            key,
            prepared_key,
            circuit_hash,
            num_public_inputs,
            version,
        })
    }

    /// Saves the verification key to a file.
    ///
    /// # Arguments
    /// * `path` - Path to save the key to
    pub fn save_to_file<P: AsRef<Path>>(&self, path: P) -> Result<(), KeyError> {
        let bytes = self.to_bytes()?;
        std::fs::write(path.as_ref(), bytes).map_err(|e| KeyError::IoError {
            message: e.to_string(),
        })
    }

    /// Loads a verification key from a file.
    ///
    /// # Arguments
    /// * `path` - Path to load the key from
    pub fn load_from_file<P: AsRef<Path>>(path: P) -> Result<Self, KeyError> {
        let bytes = std::fs::read(path.as_ref()).map_err(|e| {
            if e.kind() == std::io::ErrorKind::NotFound {
                KeyError::FileNotFound {
                    path: path.as_ref().display().to_string(),
                }
            } else {
                KeyError::IoError {
                    message: e.to_string(),
                }
            }
        })?;
        Self::from_bytes(&bytes)
    }

    /// Returns the raw arkworks verification key.
    pub fn into_inner(self) -> VerifyingKey<E> {
        self.key
    }

    /// Returns the prepared verification key for efficient verification.
    pub fn prepared(&self) -> &PreparedVerifyingKey<E> {
        &self.prepared_key
    }

    /// Serializes the verification key to a hex string.
    pub fn to_hex(&self) -> Result<String, KeyError> {
        let bytes = self.to_bytes()?;
        Ok(hex::encode(bytes))
    }

    /// Deserializes a verification key from a hex string.
    pub fn from_hex(hex_str: &str) -> Result<Self, KeyError> {
        let bytes = hex::decode(hex_str).map_err(|e| KeyError::DeserializationFailed {
            message: format!("Invalid hex: {}", e),
        })?;
        Self::from_bytes(&bytes)
    }
}

/// Computes an integrity hash of the given data.
fn compute_integrity_hash(data: &[u8]) -> [u8; 32] {
    let mut hasher = Sha256::new();
    hasher.update(data);
    hasher.finalize().into()
}

/// Computes a hash of an ACIR circuit for key identification.
pub fn compute_circuit_hash<AF: acir::AcirField>(circuit: &acir::circuit::Circuit<AF>) -> [u8; 32] {
    let mut hasher = Sha256::new();

    // Hash the circuit structure
    hasher.update(&circuit.current_witness_index.to_le_bytes());

    // Hash the number of opcodes
    hasher.update(&(circuit.opcodes.len() as u64).to_le_bytes());

    // Hash public parameters
    for witness in &circuit.public_parameters.0 {
        hasher.update(&witness.witness_index().to_le_bytes());
    }

    // Hash return values
    for witness in &circuit.return_values.0 {
        hasher.update(&witness.witness_index().to_le_bytes());
    }

    // Hash private parameters
    for witness in &circuit.private_parameters {
        hasher.update(&witness.witness_index().to_le_bytes());
    }

    hasher.finalize().into()
}

#[cfg(test)]
mod tests {
    // Tests will be added for key serialization/deserialization
}
